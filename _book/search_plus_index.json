{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Unity Manual Translation仍未但保证弃坑 贡献者 Tomnycui Paraselene Crescent Nox Eternis Algorithm Ether blance 关于翻译 随时会弃坑 不定期更新 "},"Unity_Manual.html":{"url":"Unity_Manual.html","title":"Unity User Manual (2019.2)","keywords":"","body":"Unity User Manual (2019.2) 使用 Unity 来创建 2D、3D游戏，软件和经验吧！你可以在 unity3d.com 把她领回家。 Unity User Manual 帮助你学习如何使用 Unity Editor 和她的相关服务。你可以从头看到尾，或者把她当成 reference(参考)。 如果你是第一次见到她，可以先去看一下 Working with Unity(用 Unity 工作)，然后看 Unity Tutorials(入门教程)。 "},"Scripting/ScriptingSection.html":{"url":"Scripting/ScriptingSection.html","title":"Scripting","keywords":"","body":"编程 Scripting 编程是所有你在 Unity 中写出来的程序中的基本组成部分。大多数程序需要 scripts(脚本) 来对用户的输入做出响应和需要时去安排游戏时间的发生顺序。更进一步，脚本可以用来创建图形特效，控制对象的物理表现，甚至实现游戏中角色的自定义AI系统。 这一章节介绍了在 Unity 中编程的主要概念。 Scripting Overview Scripting Tools Event System C# Job System 相关教程 Related Tutorials 查看 Scripting(编程) 文档以获取如何在 Unity 中编程的更多信息。 Knowledge Base Editor 章节 有问题查找，C# 编译错误解释入门和贴士和技巧。 Unity Forum(Unity 英文论坛) 也有常见的编程问题及其解答。 "},"Scripting/Scripting Overview/ScriptingConcepts.html":{"url":"Scripting/Scripting Overview/ScriptingConcepts.html","title":"Scripting Overview","keywords":"","body":"编程概览 Scripting Overview 尽管 Unity 实现了标准 Mono 运行时，她依旧有自己的方式和方法来用脚本访问引擎。这一章介绍了如何用脚本控制在 Unity 编辑器中创建的对象，和 Unity 的游戏特性和 Mono 运行时的关系细节。 "},"Scripting/Scripting Overview/CreatingAndUsingScripts.html":{"url":"Scripting/Scripting Overview/CreatingAndUsingScripts.html","title":"Creating and Using Scripts","keywords":"","body":"创建并使用脚本 Creating and Using Scripts GameObjects(游戏对象) 的行为由依附于它的 Components(组件) 所控制。尽管 Unity 的内建组件用途多样，你还是很快就会发现你要深入他们所提供的功能的背后才能够实现你的游戏玩法特性。Unity 允许你通过脚本创建你自己的组件。它们允许你触发游戏事件，随着时间修改组件属性并且以你喜欢的方式对用户的输入进行相应。 Unity 原生支持 C# 语言编程。C# (读作C-Sharp，莎普)是一个工业级别的语言，像 Java 和 C++ 一样。 作为对它的附加，许多其他的 .NET 语言可以在 Unity 中使用，只要可以编译出兼容的 DLL 文件-查看 这里 以获取更多细节。 学习编程思想和这些特定语言的使用涵盖在本章节的范围之中，但是还有许多其他书本，教程和资源有如何在 Unity 中的编程知识。参阅 我们网站的 学习章节 以了解进一步的细节。 创建脚本 Creating Scripts 不像其他资源，脚本是直接在 Unity 中创建的。你可以在位于 Project (项目)面板的顶部左边Create(创建)菜单创建新的脚本或者在主菜单中选择 Assets > Create > C# Script。 新脚本会在于项目面板中选择的任意文件夹中被创建。新脚本的名字会被选择，提示你改名。 现在就命名比起过会儿会更好。你输入的文件名会被用来创建文件内的起始代码，在下面有栗子。 脚本文件解析 Anatomy of a Script file 当双击 Unity 中的一个脚本资源时，它会在编辑器中打开。Unity 默认用 Visual Studio，但你也可以在 Unity 首选项(在Unity > Preferences)中的 External Tools(外部工具) 面板选别的(VSCode赛高！)。 文件的初始内容长的像这样： using UnityEngine; using System.Collections; public class MainPlayer : MonoBehaviour { // 用这个初始化 void Start () { } // 每帧调用一次 void Update () { } } 脚本通过继承 Unity 的内建类 MonoBehaviour 来联系Unity的内部工作。你可以把类比喻成一种创建可以添加到 GameObject 的 Component 类型的一种蓝图。每次你给游戏对象添加一个组件，都会创建一个被这个组件的类所定义的实例。类的名字是你创建文件时所决定的文件名。要把组件添加到游戏对象，文件名和类名必须一致。 然鹅，最需要关注的东西是两个在类中定义的函数。 Update(更新) 函数是放处理每帧游戏对象的更新的代码的。这可能包括移动，触发动作和响应用户输入，基本上是游戏过程中需要处理的任何事情。 为了使 Update 函数能够完成它的工作，在任何游戏动作发生之前能够设置变量、读取首选项并与其他游戏对象建立连接通常是很有用的。 Start 函数将在游戏开始之前被 Unity 调用(即在 Update 函数第一次被调用之前)，并且是进行任何初始化的理想场所。 有经验的程序员请注意：你可能会惊讶于对象的初始化不是在构造函数中完成的。这是因为对象的构造函数是被编辑器处理的，并且不会如你预想的那样发生在游戏开始的时候。如果你试图为脚本组件定义一个构造函数，他会干扰 Unity 的普通操作并在项目中造成问题。 控制一个游戏对象 Controlling a GameObject 像上面写的一样，脚本只定义一个组件的蓝图。它的代码不会运行，直到它的一个实例被添加到了一个游戏对象。你可以添加一个脚本(组件)通过拖拽脚本到层级面板中的一个游戏对象上，或者一个被选择的游戏对象的 Inspector(检查器) 上。在 Component 菜单中的 Script(脚本) 子菜单中也包含了所有在项目中可用的脚本，包括你自己创建的。脚本实例跟 Inspector 中别的 Component 长得几乎一样： 当添加到游戏对象之后，脚本会在你按下 Play(开始) 并运行游戏的时候开始工作。你可以添加下面的代码来验证： // Use this for initialization void Start () { Debug.Log(\"I am alive!\"); } Debug.Log 是一个把信息打到 Unity 的命令行输出上的一个简单命令。如果你现在按开始按钮，你会在主 Untiy 编辑器窗口和 Console(命令行) 窗口中看见信息(菜单：Window > General > Console)。 "},"Scripting/Scripting Overview/VariablesAndTheInspector.html":{"url":"Scripting/Scripting Overview/VariablesAndTheInspector.html","title":"Variables and the Inspector","keywords":"","body":"变量和查看器 Variables and the Inspector 创建脚本时，实质上是创建自己的新类型的组件，这些组件可以像任何其他组件一样附加到游戏对象中。 正如其他组件通常具有可在 Inspector(查看器) 中编辑的属性一样，您也可以允许脚本中的变量可以从 Inspector(查看器) 中编辑。 using UnityEngine; using System.Collections; public class MainPlayer : MonoBehaviour { public string myName; // 用这个初始化 void Start () { Debug.Log(\"I am alive and my name is \" + myName); } } 此代码在查看器中创建一个标记为“myName(我的姓名)”的可编辑字段。 Unity 通过在变量名称中出现大写字母的位置后引入一个空格来创建查看器标签。但是，这纯粹是为了显示目的，您应始终在代码中使用变量名称。如果您编辑名称，然后按 Play(播放)，您将看到该消息包含您输入的文本。 在 C# 中，必须将变量声明为公共变量才能在查看器中看到它。 Unity 实际上允许您在游戏运行时更改脚本中公共变量的值。这对于直接查看修改后的效果非常有用，且无需停止和重新编译。游戏结束时，变量的值将重置为您按下 Play 之前的值。这确保您可以自由地调整对象的设置，而不必担心造成任何永久性的破坏。 "},"Scripting/Scripting Overview/ControllingGameObjectsComponents.html":{"url":"Scripting/Scripting Overview/ControllingGameObjectsComponents.html","title":"Controlling GameObjects using components","keywords":"","body":"使用组件控制游戏对象 Controlling GameObjects using components 在 Unity 编辑器中，你可以使用 Inspector(检查器) 来更改 Component(组件) 的属性。 因此，例如，更改 Transform Component(转换组件) 的位置值将导致 GameObject(游戏对象) 的位置发生变化。同样，您更改 Renderer(渲染器) 材质的颜色或 Rigidbody(刚体) 的质量对游戏对象的外观或行为也会产生相应的影响。在大多数情况下，编写脚本也涉及修改组件属性以操作 GameObjects。但是，区别在于脚本可以在运行的时候修改属性的值或响应用户的输入。通过在正确的时间更改、创建和销毁对象，可以实现任何类型的游戏。 访问组件 Accessing components 最简单和最常见的情况是脚本需要访问附加到同一 GameObject 的其他 Component。如简介部分所述，Component 实际上是类的实例，因此第一步是获取需要使用的组件的实例的引用（好绕口）。这是使用 GetComponent(获取组件) 方法完成的。通常，您希望将 Component 对象分配给变量，这可以使用以下语句在 C# 中完成： void Start () { Rigidbody rb = GetComponent(); } 对组件实例进行引用后，可以像在检查器中那样设置其属性的值： void Start () { Rigidbody rb = GetComponent(); // 更改对象的 Rigidbody 的质量值。 rb.mass = 10f; } 一个 Inspector 做不到的附加功能是可以调用 Component 实例上的方法： void Start () { Rigidbody rb = GetComponent(); // 给 Rigidbody 加力。 rb.AddForce(Vector3.up * 10f); } 另外，请注意，可以将多个自定义脚本附加到同一对象。如果需要从一个脚本访问另一个脚本，可以像往常一样使用 GetComponent 方法，只需使用脚本类的名称（或文件名）来指定所需的组件类型。 如果尝试检索尚未实际添加到该 GameObject 的组件，则 GetComponent 方法将返回 null。如果尝试更改 null 对象上的任何值，将在运行时将出现空引用错误（null reference error）。 访问其他对象 Accessing other objects 虽然有时对象们单独工作，但通常一个对象脚本会与其他对象有联系。例如，追击的敌人可能需要知道玩家的位置。Unity 提供了多种不同的方式来检索其他对象，每个方式都适合某些情况。 使用变量链接游戏对象 Linking GameObjects with variables 查找相关 GameObject 的最直接方法是向脚本添加公共 GameObject 变量： public class Enemy : MonoBehaviour { public GameObject player; // 其他方法和变量... } 此变量将在检查器中像任何其他变量一样可见： 您现在可以将对象从 scene(场景) 或 Hierarchy(层次结构) 面板上拖到相应的变量上以分配它。GetComponent 函数和访问 Component 的值这两个操作与任何其他对象一样可用于此对象，因此可以使用如下所示的代码： public class Enemy : MonoBehaviour { public GameObject player; void Start() { // 在角色背后启动10单位的敌人。 transform.position = player.transform.position - Vector3.forward * 10f; } } 此外，如果在脚本中声明 Component 类型的变量为公共变量，则可以添加任何有这种 Component 的 GameObject。这将直接访问 GameObject 的 Component，而不是 GameObject 本身。 public Transform playerTransform; 在处理具有永久连接的单个对象时，将对象与变量链接在一起最有用。可以使用数组链接同一类型的多个对象，但链接仍必须在 Unity 编辑器中进行，而不是在运行时进行。在运行时查找对象通常很方便，Unity 提供了两种基本方法，如下所述。 查找子游戏对象 Finding child GameObjects 有时，游戏场景会使用许多相同类型的游戏对象，例如敌人、路径点和障碍物。这些可能需要由监督或响应它们的特定脚本进行跟踪（例如，所有路径点可能需要可用于路径查找脚本）。使用变量链接这些 GameObjects 是可能的，但如果每个新必须拖动到脚本上的变量上，则设计过程会变得单调乏味。同样，如果删除了一个路径点，那么必须删除对缺少的 GameObject 的变量引用是一种困扰。在这种情况下，通常最好统一管理一组游戏对象，使它们成为一个父的所有子对象。可以使用父对象的 Transform 组件检索子对象（因为所有GameObject都隐式具有 Transform 组件）： using UnityEngine; public class WaypointManager : MonoBehaviour { public Transform[] waypoints; void Start() { waypoints = new Transform[transform.childCount]; int i = 0; foreach (Transform t in transform) { waypoints[i++] = t; } } } 您还可以使用 Transform.Find 函数按名称查找特定子对象： transform.Find(\"Gun\"); 当对象具有可以在游戏过程中添加和删除的子对象时，这非常有用。可以拿起并放下的武器就是一个很好的例子。 按名称或标签查找游戏对象 Finding GameObjects by Name or Tag 只要您有一些信息来标识它们，就可以在场景层次结构的任意位置找到游戏对象。可以使用 GameObject.Find 函数按名称检索单个对象： GameObject player; void Start() { player = GameObject.Find(\"MainHeroCharacter\"); } 对象或对象集合也可以通过其标记使用 GameObject.FindWithTag 和 GameObject.FindGameObject 与标记函数进行定位： GameObject player; GameObject[] enemies; void Start() { player = GameObject.FindWithTag(\"Player\"); enemies = GameObject.FindGameObjectsWithTag(\"Enemy\"); } "},"Scripting/Scripting Overview/EventFunctions.html":{"url":"Scripting/Scripting Overview/EventFunctions.html","title":"Event Functions","keywords":"","body":"事件方法 Event Functions Unity 中的脚本不像传统程序所做的那样不停在循环中重复地运行代码知道它完成任务。取而代之，Unity 间歇地把控制权交给脚本，通过调用在脚本中定义的特定方法。当一个方法执行完毕，控制权就会交回 Unity。这些方法被称作事件方法，因为他们被 Unity 所激活，来对游戏过程中发生的事件作出反应。举个核桃，你已经见识过 Update(更新) 方法（在每帧更新发生时调用）和 Start(开始) 方法（在对象第一次帧更新时调用）了。Unity 中还有许多其他的可用方法；完整的列表在 MonoBehaviour 类脚本参考页面，包含它们的详细用法。下面是一些最常用和重要的事件。 直接更新事件 Regular Update Events 游戏十分像每帧都在动态生成的动画。游戏的一个关键内容是在每帧被渲染之前对象的位置，状态及表现做出改变。Update 方法是这类代码在 Unity 中的主要舞台（有点怪？理解理解）。Update 在每帧渲染前和动画计算前被调用。 void Update() { float distance = speed * Time.deltaTime * Input.GetAxis(\"Horizontal\"); transform.Translate(Vector3.right * distance); } Physics engine(物理引擎) 在不与帧 rendering(渲染) 相关的时间步长中以类似的方式进行更新。一个单独的事件方法 FixedUpdate(固定更新) 会在每次物理更新前被调用。因为物理更新和帧更新发生频率不同，比起 Update 方法，物理代码在 FixedUpdate 方法会得到更加准确的结果。 void FixedUpdate() { Vector3 force = transform.forward * driveForce * Input.GetAxis(\"Vertical\"); __rigidbody__.AddForce(force); } 有时在 scene(场景) 中所有的对象的 FixedUpdate 方法被调用和所有动画被计算之后的某个时刻做更多的改动很有用。举个花生，camera(相机) 要保持聚焦在目标对象上；相机方向的改动必须在目标对象移动后做出。另一个瓜子是脚本代码应该覆盖动画的效果(例如，让角色的头朝向场景中的目标对象)。LateUpdate(延迟更新) 方法可以用于这些情景。 void LateUpdate() { Camera.main.transform.LookAt(target.transform); } 初始化事件 Initialization Events 能够在任何游戏更新发生前调用初始化代码常常很有用。Start(开始) 方法在对象第一次帧更新或者物理更新之前被调用。在场景加载时，场景中每一个对象的 Awake(唤醒) 方法会被调用。注意虽然这么多的对象的 Start 和 Awake 方法调用的顺序没有特定的顺序，但所有的 Awake 方法都会在第一个 Start 调用前完成。这意味着 Start 方法中的代码可以利用之前在 Awake 阶段中执行了的初始化的内容。 GUI 事件 GUI events Unity 有一个系统可以在场景的主要动作上渲染 GUI 控件并对点击控制做出响应。处理这些代码比起普通的帧更新稍有不同，所以它们应该放置在 OnGUI 方法中，它会被定期调用。 void OnGUI() { GUI.Label(labelRect, \"Game Over\"); } 您还可以检测发生在 GameObject(游戏物体) 上的鼠标事件，当它出现在场景中。这可以用来标志武器或者显示关于在鼠标指针下面的角色的信息。一组 OnMouseXXX 事件方法（例如 OnMouseOver OnMouseDown）可以让脚本去响应用户的鼠标动作。又一个坚果，如果鼠标在一个特定对象上点击，那么如果对象的 OnMouseDown 方法就会被调用（如果有的话）。 物理事件 Physics events 物理引擎会报告发生在一个对象上的撞击，通过调用那个对象的脚本。OnCollisionEnter, OnCollisionStay 和 OnCollisionExit 方法会被调用，当联系被创建，保持和破坏的时候。当对象的 collider(碰撞体) 被配置成 Trigger(触发器) 的时候，对应的方法就会被调用（就是 collider 只是检测有什么进入他了，而不会做出物理响应）。这些方法可能在一次物理更新中被调用多次，如果有多于一次接触被检测到。因此调用的时候会传递一个包含碰撞细节的参数（像位置，要碰你的对象的身份什么的）。 void OnCollisionEnter(otherObj: Collision) { if (otherObj.tag == \"Arrow\") { ApplyDamage(10); } } "},"Scripting/Scripting Overview/TimeFrameManagement.html":{"url":"Scripting/Scripting Overview/TimeFrameManagement.html","title":"Time and Framerate Management","keywords":"","body":"时间和帧数控制 Time and Framerate Management Update(更新) 方法允许你直接在脚本中监视输入和其他事件并对此做出恰当的动作。举个梨子，你可以在“前进”键按下时移动角色。在处理这一些基于时间的动作时要记住的一个重要的事是游戏的帧率不恒定，Update 方法调用的时间也不恒定。 举一个它的例子，考虑平稳地把一个对象向前移动，每帧一次。看起来你只要每帧都把对象移动固定距离就够了： //C# script example using UnityEngine; using System.Collections; public class ExampleScript : MonoBehaviour { public float distancePerFrame; void Update() { transform.Translate(0, 0, distancePerFrame); } } //JS script example var distancePerFrame: float; function Update() { transform.Translate(0, 0, distancePerFrame); } 然而，考虑到每帧的时间不是固定的，对象会表现得速度不是固定的。如果帧时间是10毫秒那么这个对象会每一秒向前移动 distancePerFrame(每帧距离) 100次。但如果帧时间增加到25毫秒（取决于CPU）那么它只会向前40次，因此行走的距离更短。解决方案是按帧时间决定移动距离，你可以从 Time.deltaTime 属性获取帧时间： //C# 脚本示范 using UnityEngine; using System.Collections; public class ExampleScript : MonoBehaviour { public float distancePerSecond; void Update() { transform.Translate(0, 0, distancePerSecond * Time.deltaTime); } } //JS 脚本示范 var distancePerSecond: float; function Update() { transform.Translate(0, 0, distancePerSecond * Time.deltaTime); } 注意移动距离现在以 distancePerSecond(每秒距离) 给出，而不是 distancePerFrame。当帧率改变，移动距离大小会随之改变，因此对象速度是固定的。 固定时间步长 Fixed Timestep 不像主要的帧更新，Unity 的物理系统是以 fixed timestep(固定时间步长) 工作的，这对于模拟的准确性和一致性很重要。在物理更新开始时，Unity 将会在上一次物理更新结束时设置固定时间步长的“闹钟”。物理系统会执行计算直到闹钟响起。 你可以在 Time(时间) 窗口改变固定时间步长的长短，并且也在脚本中通过 Time.fixedDeltaTime 属性得到。注意更低的时间步长反映在更频繁的物理更新和更精确的模拟上，但这会导致更高的 CPU 负载。你一般不用改默认的时间步长除非你对物理引擎有更高的要求。 最大允许时间步长 固定的时间步长使物理模拟相对于现实时间保持精确，但它如果太小，会在游戏的物理需求过大和游戏帧率变低的时候造成问题（比如有很多对象要渲染的时候）。主要帧更新必须“挤”在固定的物理更新中间，而且如果有很多东西要渲染，几个物理更新可以在一帧之中更新发生。由于图形方面的帧时间、对象的位置和其他属性在帧的开始被冻结，图形可能与更频繁更新的物理不同步。 自然你只有那么多 CPU 资源，但 Unity 可以让你选择有效降低物理时间来让帧处理跟上。Maximum Allowed Timestep(最大允许时间步长) 设置（在 Time 窗口中）给 Unity 用来处理物理的时间和FixedUpdate在一帧之间的调用做出了限制。如果一帧的更新用了超过 Maximum Allowed Timestep 来处理，物理引擎会“暂停时间”来让帧处理跟上。当帧更新完成，物理时间会恢复，且从上次暂停开始没有时间流动。结果是 rigidbodies(刚体) 相对现实时间不会像往常一样完美地移动，而是稍微变慢。但是，物理“时钟”会把它们当作正常移动。物理时间的变慢一般是难以察觉的而且对于游戏性能是可以接受的让步。 时间缩放 Time Scale 对于特别的效果，比如“时符「The World」”，有时候让时间暂缓来让动画和脚本响应发生在降低的速率会挺有用。更进一步，你可能有时候想要完全暂停时间，像游戏暂停。Unity 有一个 Time Scale(时间缩放) 属性可以控制相对于现实时间游戏进行得多块。如果比例被设置到1.0那么游戏时间和现实时间相同。2.0是两倍速度（动作会变快）而0.5速度会减缓到一半。0会让时间完全“停止”。注意时间缩放不会真正减慢程序执行而只是更改了通过方法 Time.deltaTime 和 Time.fixedDeltaTime 返回的时间步长。Update 方法会被调用得更加频繁，而每帧的 deltaTime 会减少。别的脚本方法不会受时间缩放影响，打个比方，当游戏暂停的时候你可以显示正常交互的 GUI 。 Time 窗口有可以让你设置全局时间缩放的属性，但是更常见的是在脚本中通过 Time.timeScale 属性设置。 //C# script example using UnityEngine; using System.Collections; public class ExampleScript : MonoBehaviour { void Pause() { Time.timeScale = 0; } void Resume() { Time.timeScale = 1; } } //JS script example function Pause() { Time.timeScale = 0; } function Resume() { Time.timeScale = 1; } 录制帧率 Capture Framerate 时间管理一个非常特殊的情况是当你想要录制游戏的时候。因为保存屏幕图像需要相当的时间，如果你尝试在普通的游戏进程中这么做，正常的游戏帧率会大大降低。这会导致视频不能体现正常的游戏表现。 幸运的是，Unity 提供了一个 Capture Framerate(录制帧率) 的属性可以让你解决这个问题。当这个属性的值设置成非零时，游戏的时间会变慢并且帧更新会定期精确进行。每帧的时间间隔等于 1 / Time.captureFramerate，所以如果值设成 5.0 那么更新每秒会发生五次。因为在帧率上的需求显著降低，你会有充足的时间去保存屏幕快照和进行其他行为： //C# 脚本范例 using UnityEngine; using System.Collections; public class ExampleScript : MonoBehaviour { // Capture frames as a screenshot sequence. Images are // stored as PNG files in a folder - these can be combined into // a movie using image utility software (eg, QuickTime Pro). // The folder to contain our screenshots. // If the folder exists we will append numbers to create an empty folder. string folder = \"ScreenshotFolder\"; int frameRate = 25; void Start () { // Set the playback framerate (real time will not relate to game time after this). Time.captureFramerate = frameRate; // Create the folder System.IO.Directory.CreateDirectory(folder); } void Update () { // Append filename to folder name (format is '0005 shot.png\"') string name = string.Format(\"{0}/{1:D04} shot.png\", folder, Time.frameCount ); // Capture the screenshot to the specified file. Application.CaptureScreenshot(name); } } //JS 脚本范例 // Capture frames as a screenshot sequence. Images are // stored as PNG files in a folder - these can be combined into // a movie using image utility software (eg, QuickTime Pro). // The folder to contain our screenshots. // If the folder exists we will append numbers to create an empty folder. var folder = \"ScreenshotFolder\"; var frameRate = 25; function Start () { // Set the playback framerate (real time will not relate to game time after this). Time.captureFramerate = frameRate; // Create the folder System.IO.Directory.CreateDirectory(folder); } function Update () { // Append filename to folder name (format is '0005 shot.png\"') var name = String.Format(\"{0}/{1:D04} shot.png\", folder, Time.frameCount ); // Capture the screenshot to the specified file. Application.CaptureScreenshot(name); } "},"Scripting/Scripting Overview/Coroutines.html":{"url":"Scripting/Scripting Overview/Coroutines.html","title":"Coroutines","keywords":"","body":"Conroutines 当你调用一个函数时，它会一直运行到它返回。这实际上意味着任何在函数中进行的动作必须在单次帧更新中发生；一次函数调用不能够包含渐变的动画或者一系列与时间有关的事件。举个核桃，我们要逐渐减少一个对象的 alpha 值（可见度）直到它完全不可见： void Fade() { for (float ft = 1f; ft >= 0; ft -= 0.1f) { Color c = renderer.material.color; c.a = ft; renderer.material.color = c; } } 如你所料，Fade(褪色) 方法不会发挥出你预期的效果。为了让褪色的过程可见，alpha 值必须在一段帧中逐渐减少来让中间的过程被渲染。但是，这段代码会在一帧之中执行完毕。中间值永远不会被看见，而对象会瞬间消失。 一个可能的解决方案是在 Update(更新) 方法中增加每一帧都褪色一点的代码来实现。可是，用协同函数(coroutine)来实现这类工作更加方便。 协同函数像是一种能够暂停执行并把控制权返回 Unity，但在随后的帧又可以在中断的地方继续的函数。在 C# 中，协同函数像这样声明： IEnumerator Fade() { for (float ft = 1f; ft >= 0; ft -= 0.1f) { Color c = renderer.material.color; c.a = ft; renderer.material.color = c; yield return null; } } 它本质上是一个返回值类型为 IEnumerator 和有 yield return 语句的方法。yield return null 行是程序暂停和在接下来的帧恢复的点。要使协同方法开始运行，你要用到 StartCoroutine 方法： void Update() { if (Input.GetKeyDown(\"f\")) { StartCoroutine(\"Fade\"); } } 你会注意到循环计数器在协同函数的生命周期内保持了它当前的值。实际上，任何变量或者参数在函数执行的间隙都会正确地保存。 默认协同函数会在暂停之后的下一帧恢复，但你也可以用 WaitForSeconds 实现延时： IEnumerator Fade() { for (float ft = 1f; ft >= 0; ft -= 0.1f) { Color c = renderer.material.color; c.a = ft; renderer.material.color = c; yield return new WaitForSeconds(.1f); } } 这个方法是把效果延伸一段时间的一种途径，但也是一种有用的优化手段。许多游戏中的任务需要逐渐进行，而最显然的方式是把代码放进 Update 方法中。但是，Update 方法每秒钟会被调用很多次。当一个任务不需要被如此频繁地调用时，你可以把它放在协同函数中来定期更新，但不是每一帧。一个例子是警告玩家敌人接近的警告。代码看起来长这样： function ProximityCheck() { for (int i = 0; i 如果有很多敌人，每一帧都调用这个方法可能会导致严重的过载。取而代之，你可以使用协同函数来每秒调用十次： IEnumerator DoCheck() { for(;;) { ProximityCheck(); yield return new WaitForSeconds(.1f); } } 这会大大减少检查的次数，而游戏过程不会产生任何可察觉的改变。 注意：你可以用 StopCoroutine 和 StopAllCoroutines 停止一个协同函数。当协同函数添加到的 GameObject(游戏对象) 被用 SetActive(false) 禁用的时候也会停止。调用Destroy(example)（当 example 是一个 MonoBehaviour 实例的时候）会马上触发 OnDisable 且协同函数会被调用，以有效地将它停止。最终，OnDestroy 会在帧结束的时候被调用。 当通过设置 enable 为 false 来禁用 MonoBehaivour 实例时，协同函数不会停止。 "},"Scripting/Scripting Overview/CreateDestroyObjects.html":{"url":"Scripting/Scripting Overview/CreateDestroyObjects.html","title":"Creating and Destroying GameObjects","keywords":"","body":"创建和销毁游戏对象 Creating and Destroying GameObjects 有一些游戏在场景中保持固定数量的对象，但对于角色、宝藏和其他对象来说，在游戏过程中创建和销毁它们是很常见的事。在 Unity，GameObject(游戏对象) 可以被 Instantiate(实例化) 方法创建，作为一个已存在的对象的副本： public GameObject enemy; void Start() { for (int i = 0; i 注意被复制对象必须要在场景中显示。使用从编辑器中的 Project(项目) 面板拖到公共变量的 prefab(预制件) 更加常用。同时，实例化一个 GameObject 会复制所有在原对象上的 Components(组件)。 还有一个 Destroy(销毁) 方法可以用来销毁对象，在帧更新完成后或者可选的短暂延时一会儿： void OnCollisionEnter(Collision otherObj) { if (otherObj.gameObject.tag == \"Missile\") { Destroy(gameObject,.5f); } } 注意 Destroy 方法可以摧毁个别组件而不影响 GameObject 自己。一个常见的错误： Destroy(this); 它只会摧毁调用这个函数的脚本组件，而不是摧毁它添加到的 GameObject。 "}}