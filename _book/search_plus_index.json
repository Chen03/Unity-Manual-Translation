{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Unity Manual Translation仍未但保证弃坑 贡献者 Tomnycui Paraselene Crescent Nox Eternis Algorithm Ether blance 关于翻译 随时会弃坑 不定期更新 "},"Unity_Manual.html":{"url":"Unity_Manual.html","title":"Unity User Manual (2019.2)","keywords":"","body":"Unity User Manual (2019.2) 使用 Unity 来创建 2D、3D游戏，软件和经验吧！你可以在 unity3d.com 把她领回家。 Unity User Manual 帮助你学习如何使用 Unity Editor 和她的相关服务。你可以从头看到尾，或者把她当成 reference(参考)。 如果你是第一次见到她，可以先去看一下 Working with Unity(用 Unity 工作)，然后看 Unity Tutorials(入门教程)。 "},"Scripting/ScriptingSection.html":{"url":"Scripting/ScriptingSection.html","title":"Scripting","keywords":"","body":"编程 Scripting 编程是所有你在 Unity 中写出来的程序中的基本组成部分。大多数程序需要 scripts(脚本) 来对用户的输入做出响应和需要时去安排游戏时间的发生顺序。更进一步，脚本可以用来创建图形特效，控制对象的物理表现，甚至实现游戏中角色的自定义AI系统。 这一章节介绍了在 Unity 中编程的主要概念。 Scripting Overview Scripting Tools Event System C# Job System 相关教程 Related Tutorials 查看 Scripting(编程) 文档以获取如何在 Unity 中编程的更多信息。 Knowledge Base Editor 章节 有问题查找，C# 编译错误解释入门和贴士和技巧。 Unity Forum(Unity 英文论坛) 也有常见的编程问题及其解答。 "},"Scripting/Scripting Overview/ScriptingConcepts.html":{"url":"Scripting/Scripting Overview/ScriptingConcepts.html","title":"Scripting Overview","keywords":"","body":"编程概览 Scripting Overview 尽管 Unity 实现了标准 Mono 运行时，她依旧有自己的方式和方法来用脚本访问引擎。这一章介绍了如何用脚本控制在 Unity 编辑器中创建的对象，和 Unity 的游戏特性和 Mono 运行时的关系细节。 "},"Scripting/Scripting Overview/CreatingAndUsingScripts.html":{"url":"Scripting/Scripting Overview/CreatingAndUsingScripts.html","title":"Creating and Using Scripts","keywords":"","body":"创建并使用脚本 Creating and Using Scripts GameObjects(游戏对象) 的行为由依附于它的 Components(组件) 所控制。尽管 Unity 的内建组件用途多样，你还是很快就会发现你要深入他们所提供的功能的背后才能够实现你的游戏玩法特性。Unity 允许你通过脚本创建你自己的组件。它们允许你触发游戏事件，随着时间修改组件属性并且以你喜欢的方式对用户的输入进行相应。 Unity 原生支持 C# 语言编程。C# (读作C-Sharp，莎普)是一个工业级别的语言，像 Java 和 C++ 一样。 作为对它的附加，许多其他的 .NET 语言可以在 Unity 中使用，只要可以编译出兼容的 DLL 文件-查看 这里 以获取更多细节。 学习编程思想和这些特定语言的使用涵盖在本章节的范围之中，但是还有许多其他书本，教程和资源有如何在 Unity 中的编程知识。参阅 我们网站的 学习章节 以了解进一步的细节。 创建脚本 Creating Scripts 不像其他资源，脚本是直接在 Unity 中创建的。你可以在位于 Project (项目)面板的顶部左边Create(创建)菜单创建新的脚本或者在主菜单中选择 Assets > Create > C# Script。 新脚本会在于项目面板中选择的任意文件夹中被创建。新脚本的名字会被选择，提示你改名。 现在就命名比起过会儿会更好。你输入的文件名会被用来创建文件内的起始代码，在下面有栗子。 脚本文件解析 Anatomy of a Script file 当双击 Unity 中的一个脚本资源时，它会在编辑器中打开。Unity 默认用 Visual Studio，但你也可以在 Unity 首选项(在Unity > Preferences)中的 External Tools(外部工具) 面板选别的(VSCode赛高！)。 文件的初始内容长的像这样： using UnityEngine; using System.Collections; public class MainPlayer : MonoBehaviour { // 用这个初始化 void Start () { } // 每帧调用一次 void Update () { } } 脚本通过继承 Unity 的内建类 MonoBehaviour 来联系Unity的内部工作。你可以把类比喻成一种创建可以添加到 GameObject 的 Component 类型的一种蓝图。每次你给游戏对象添加一个组件，都会创建一个被这个组件的类所定义的实例。类的名字是你创建文件时所决定的文件名。要把组件添加到游戏对象，文件名和类名必须一致。 然鹅，最需要关注的东西是两个在类中定义的函数。 Update(更新) 函数是放处理每帧游戏对象的更新的代码的。这可能包括移动，触发动作和响应用户输入，基本上是游戏过程中需要处理的任何事情。 为了使 Update 函数能够完成它的工作，在任何游戏动作发生之前能够设置变量、读取首选项并与其他游戏对象建立连接通常是很有用的。 Start 函数将在游戏开始之前被 Unity 调用(即在 Update 函数第一次被调用之前)，并且是进行任何初始化的理想场所。 有经验的程序员请注意：你可能会惊讶于对象的初始化不是在构造函数中完成的。这是因为对象的构造函数是被编辑器处理的，并且不会如你预想的那样发生在游戏开始的时候。如果你试图为脚本组件定义一个构造函数，他会干扰 Unity 的普通操作并在项目中造成问题。 控制一个游戏对象 Controlling a GameObject 像上面写的一样，脚本只定义一个组件的蓝图。它的代码不会运行，直到它的一个实例被添加到了一个游戏对象。你可以添加一个脚本(组件)通过拖拽脚本到层级面板中的一个游戏对象上，或者一个被选择的游戏对象的 Inspector(检查器) 上。在 Component 菜单中的 Script(脚本) 子菜单中也包含了所有在项目中可用的脚本，包括你自己创建的。脚本实例跟 Inspector 中别的 Component 长得几乎一样： 当添加到游戏对象之后，脚本会在你按下 Play(开始) 并运行游戏的时候开始工作。你可以添加下面的代码来验证： // Use this for initialization void Start () { Debug.Log(\"I am alive!\"); } Debug.Log 是一个把信息打到 Unity 的命令行输出上的一个简单命令。如果你现在按开始按钮，你会在主 Untiy 编辑器窗口和 Console(命令行) 窗口中看见信息(菜单：Window > General > Console)。 "},"Scripting/Scripting Overview/VariablesAndTheInspector.html":{"url":"Scripting/Scripting Overview/VariablesAndTheInspector.html","title":"Variables and the Inspector","keywords":"","body":"变量和查看器 Variables and the Inspector 创建脚本时，实质上是创建自己的新类型的组件，这些组件可以像任何其他组件一样附加到游戏对象中。 正如其他组件通常具有可在 Inspector(查看器) 中编辑的属性一样，您也可以允许脚本中的变量可以从 Inspector(查看器) 中编辑。 using UnityEngine; using System.Collections; public class MainPlayer : MonoBehaviour { public string myName; // 用这个初始化 void Start () { Debug.Log(\"I am alive and my name is \" + myName); } } 此代码在查看器中创建一个标记为“myName(我的姓名)”的可编辑字段。 Unity 通过在变量名称中出现大写字母的位置后引入一个空格来创建查看器标签。但是，这纯粹是为了显示目的，您应始终在代码中使用变量名称。如果您编辑名称，然后按 Play(播放)，您将看到该消息包含您输入的文本。 在 C# 中，必须将变量声明为公共变量才能在查看器中看到它。 Unity 实际上允许您在游戏运行时更改脚本中公共变量的值。这对于直接查看修改后的效果非常有用，且无需停止和重新编译。游戏结束时，变量的值将重置为您按下 Play 之前的值。这确保您可以自由地调整对象的设置，而不必担心造成任何永久性的破坏。 "},"Scripting/Scripting Overview/ControllingGameObjectsComponents.html":{"url":"Scripting/Scripting Overview/ControllingGameObjectsComponents.html","title":"Controlling GameObjects using components","keywords":"","body":"使用组件控制游戏对象 Controlling GameObjects using components 在 Unity 编辑器中，你可以使用 Inspector(检查器) 来更改 Component(组件) 的属性。 因此，例如，更改 Transform Component(转换组件) 的位置值将导致 GameObject(游戏对象) 的位置发生变化。同样，您更改 Renderer(渲染器) 材质的颜色或 Rigidbody(刚体) 的质量对游戏对象的外观或行为也会产生相应的影响。在大多数情况下，编写脚本也涉及修改组件属性以操作 GameObjects。但是，区别在于脚本可以在运行的时候修改属性的值或响应用户的输入。通过在正确的时间更改、创建和销毁对象，可以实现任何类型的游戏。 访问组件 Accessing components 最简单和最常见的情况是脚本需要访问附加到同一 GameObject 的其他 Component。如简介部分所述，Component 实际上是类的实例，因此第一步是获取需要使用的组件的实例的引用（好绕口）。这是使用 GetComponent(获取组件) 方法完成的。通常，您希望将 Component 对象分配给变量，这可以使用以下语句在 C# 中完成： void Start () { Rigidbody rb = GetComponent(); } 对组件实例进行引用后，可以像在检查器中那样设置其属性的值： void Start () { Rigidbody rb = GetComponent(); // 更改对象的 Rigidbody 的质量值。 rb.mass = 10f; } 一个 Inspector 做不到的附加功能是可以调用 Component 实例上的方法： void Start () { Rigidbody rb = GetComponent(); // 给 Rigidbody 加力。 rb.AddForce(Vector3.up * 10f); } 另外，请注意，可以将多个自定义脚本附加到同一对象。如果需要从一个脚本访问另一个脚本，可以像往常一样使用 GetComponent 方法，只需使用脚本类的名称（或文件名）来指定所需的组件类型。 如果尝试检索尚未实际添加到该 GameObject 的组件，则 GetComponent 方法将返回 null。如果尝试更改 null 对象上的任何值，将在运行时将出现空引用错误（null reference error）。 访问其他对象 Accessing other objects 虽然有时对象们单独工作，但通常一个对象脚本会与其他对象有联系。例如，追击的敌人可能需要知道玩家的位置。Unity 提供了多种不同的方式来检索其他对象，每个方式都适合某些情况。 使用变量链接游戏对象 Linking GameObjects with variables 查找相关 GameObject 的最直接方法是向脚本添加公共 GameObject 变量： public class Enemy : MonoBehaviour { public GameObject player; // 其他方法和变量... } 此变量将在检查器中像任何其他变量一样可见： 您现在可以将对象从 scene(场景) 或 Hierarchy(层次结构) 面板上拖到相应的变量上以分配它。GetComponent 函数和访问 Component 的值这两个操作与任何其他对象一样可用于此对象，因此可以使用如下所示的代码： public class Enemy : MonoBehaviour { public GameObject player; void Start() { // 在角色背后启动10单位的敌人。 transform.position = player.transform.position - Vector3.forward * 10f; } } 此外，如果在脚本中声明 Component 类型的变量为公共变量，则可以添加任何有这种 Component 的 GameObject。这将直接访问 GameObject 的 Component，而不是 GameObject 本身。 public Transform playerTransform; 在处理具有永久连接的单个对象时，将对象与变量链接在一起最有用。可以使用数组链接同一类型的多个对象，但链接仍必须在 Unity 编辑器中进行，而不是在运行时进行。在运行时查找对象通常很方便，Unity 提供了两种基本方法，如下所述。 查找子游戏对象 Finding child GameObjects 有时，游戏场景会使用许多相同类型的游戏对象，例如敌人、路径点和障碍物。这些可能需要由监督或响应它们的特定脚本进行跟踪（例如，所有路径点可能需要可用于路径查找脚本）。使用变量链接这些 GameObjects 是可能的，但如果每个新必须拖动到脚本上的变量上，则设计过程会变得单调乏味。同样，如果删除了一个路径点，那么必须删除对缺少的 GameObject 的变量引用是一种困扰。在这种情况下，通常最好统一管理一组游戏对象，使它们成为一个父的所有子对象。可以使用父对象的 Transform 组件检索子对象（因为所有GameObject都隐式具有 Transform 组件）： using UnityEngine; public class WaypointManager : MonoBehaviour { public Transform[] waypoints; void Start() { waypoints = new Transform[transform.childCount]; int i = 0; foreach (Transform t in transform) { waypoints[i++] = t; } } } 您还可以使用 Transform.Find 函数按名称查找特定子对象： transform.Find(\"Gun\"); 当对象具有可以在游戏过程中添加和删除的子对象时，这非常有用。可以拿起并放下的武器就是一个很好的例子。 按名称或标签查找游戏对象 Finding GameObjects by Name or Tag 只要您有一些信息来标识它们，就可以在场景层次结构的任意位置找到游戏对象。可以使用 GameObject.Find 函数按名称检索单个对象： GameObject player; void Start() { player = GameObject.Find(\"MainHeroCharacter\"); } 对象或对象集合也可以通过其标记使用 GameObject.FindWithTag 和 GameObject.FindGameObject 与标记函数进行定位： GameObject player; GameObject[] enemies; void Start() { player = GameObject.FindWithTag(\"Player\"); enemies = GameObject.FindGameObjectsWithTag(\"Enemy\"); } "},"Scripting/Scripting Overview/EventFunctions.html":{"url":"Scripting/Scripting Overview/EventFunctions.html","title":"Event Functions","keywords":"","body":"事件方法 Event Functions Unity 中的脚本不像传统程序所做的那样不停在循环中重复地运行代码知道它完成任务。取而代之，Unity 间歇地把控制权交给脚本，通过调用在脚本中定义的特定方法。当一个方法执行完毕，控制权就会交回 Unity。这些方法被称作事件方法，因为他们被 Unity 所激活，来对游戏过程中发生的事件作出反应。举个核桃，你已经见识过 Update(更新) 方法（在每帧更新发生时调用）和 Start(开始) 方法（在对象第一次帧更新时调用）了。Unity 中还有许多其他的可用方法；完整的列表在 MonoBehaviour 类脚本参考页面，包含它们的详细用法。下面是一些最常用和重要的事件。 直接更新事件 Regular Update Events 游戏十分像每帧都在动态生成的动画。游戏的一个关键内容是在每帧被渲染之前对象的位置，状态及表现做出改变。Update 方法是这类代码在 Unity 中的主要舞台（有点怪？理解理解）。Update 在每帧渲染前和动画计算前被调用。 void Update() { float distance = speed * Time.deltaTime * Input.GetAxis(\"Horizontal\"); transform.Translate(Vector3.right * distance); } Physics engine(物理引擎) 在不与帧 rendering(渲染) 相关的时间步长中以类似的方式进行更新。一个单独的事件方法 FixedUpdate(固定更新) 会在每次物理更新前被调用。因为物理更新和帧更新发生频率不同，比起 Update 方法，物理代码在 FixedUpdate 方法会得到更加准确的结果。 void FixedUpdate() { Vector3 force = transform.forward * driveForce * Input.GetAxis(\"Vertical\"); __rigidbody__.AddForce(force); } 有时在 scene(场景) 中所有的对象的 FixedUpdate 方法被调用和所有动画被计算之后的某个时刻做更多的改动很有用。举个花生，camera(相机) 要保持聚焦在目标对象上；相机方向的改动必须在目标对象移动后做出。另一个瓜子是脚本代码应该覆盖动画的效果(例如，让角色的头朝向场景中的目标对象)。LateUpdate(延迟更新) 方法可以用于这些情景。 void LateUpdate() { Camera.main.transform.LookAt(target.transform); } 初始化事件 Initialization Events 能够在任何游戏更新发生前调用初始化代码常常很有用。Start(开始) 方法在对象第一次帧更新或者物理更新之前被调用。在场景加载时，场景中每一个对象的 Awake(唤醒) 方法会被调用。注意虽然这么多的对象的 Start 和 Awake 方法调用的顺序没有特定的顺序，但所有的 Awake 方法都会在第一个 Start 调用前完成。这意味着 Start 方法中的代码可以利用之前在 Awake 阶段中执行了的初始化的内容。 GUI 事件 GUI events Unity 有一个系统可以在场景的主要动作上渲染 GUI 控件并对点击控制做出响应。处理这些代码比起普通的帧更新稍有不同，所以它们应该放置在 OnGUI 方法中，它会被定期调用。 void OnGUI() { GUI.Label(labelRect, \"Game Over\"); } 您还可以检测发生在 GameObject(游戏物体) 上的鼠标事件，当它出现在场景中。这可以用来标志武器或者显示关于在鼠标指针下面的角色的信息。一组 OnMouseXXX 事件方法（例如 OnMouseOver OnMouseDown）可以让脚本去响应用户的鼠标动作。又一个坚果，如果鼠标在一个特定对象上点击，那么如果对象的 OnMouseDown 方法就会被调用（如果有的话）。 物理事件 Physics events 物理引擎会报告发生在一个对象上的撞击，通过调用那个对象的脚本。OnCollisionEnter, OnCollisionStay 和 OnCollisionExit 方法会被调用，当联系被创建，保持和破坏的时候。当对象的 collider(碰撞体) 被配置成 Trigger(触发器) 的时候，对应的方法就会被调用（就是 collider 只是检测有什么进入他了，而不会做出物理响应）。这些方法可能在一次物理更新中被调用多次，如果有多于一次接触被检测到。因此调用的时候会传递一个包含碰撞细节的参数（像位置，要碰你的对象的身份什么的）。 void OnCollisionEnter(otherObj: Collision) { if (otherObj.tag == \"Arrow\") { ApplyDamage(10); } } "},"Scripting/Scripting Overview/TimeFrameManagement.html":{"url":"Scripting/Scripting Overview/TimeFrameManagement.html","title":"Time and Framerate Management","keywords":"","body":"时间和帧数控制 Time and Framerate Management Update(更新) 方法允许你直接在脚本中监视输入和其他事件并对此做出恰当的动作。举个梨子，你可以在“前进”键按下时移动角色。在处理这一些基于时间的动作时要记住的一个重要的事是游戏的帧率不恒定，Update 方法调用的时间也不恒定。 举一个它的例子，考虑平稳地把一个对象向前移动，每帧一次。看起来你只要每帧都把对象移动固定距离就够了： //C# script example using UnityEngine; using System.Collections; public class ExampleScript : MonoBehaviour { public float distancePerFrame; void Update() { transform.Translate(0, 0, distancePerFrame); } } //JS script example var distancePerFrame: float; function Update() { transform.Translate(0, 0, distancePerFrame); } 然而，考虑到每帧的时间不是固定的，对象会表现得速度不是固定的。如果帧时间是10毫秒那么这个对象会每一秒向前移动 distancePerFrame(每帧距离) 100次。但如果帧时间增加到25毫秒（取决于CPU）那么它只会向前40次，因此行走的距离更短。解决方案是按帧时间决定移动距离，你可以从 Time.deltaTime 属性获取帧时间： //C# 脚本示范 using UnityEngine; using System.Collections; public class ExampleScript : MonoBehaviour { public float distancePerSecond; void Update() { transform.Translate(0, 0, distancePerSecond * Time.deltaTime); } } //JS 脚本示范 var distancePerSecond: float; function Update() { transform.Translate(0, 0, distancePerSecond * Time.deltaTime); } 注意移动距离现在以 distancePerSecond(每秒距离) 给出，而不是 distancePerFrame。当帧率改变，移动距离大小会随之改变，因此对象速度是固定的。 固定时间步长 Fixed Timestep 不像主要的帧更新，Unity 的物理系统是以 fixed timestep(固定时间步长) 工作的，这对于模拟的准确性和一致性很重要。在物理更新开始时，Unity 将会在上一次物理更新结束时设置固定时间步长的“闹钟”。物理系统会执行计算直到闹钟响起。 你可以在 Time(时间) 窗口改变固定时间步长的长短，并且也在脚本中通过 Time.fixedDeltaTime 属性得到。注意更低的时间步长反映在更频繁的物理更新和更精确的模拟上，但这会导致更高的 CPU 负载。你一般不用改默认的时间步长除非你对物理引擎有更高的要求。 最大允许时间步长 固定的时间步长使物理模拟相对于现实时间保持精确，但它如果太小，会在游戏的物理需求过大和游戏帧率变低的时候造成问题（比如有很多对象要渲染的时候）。主要帧更新必须“挤”在固定的物理更新中间，而且如果有很多东西要渲染，几个物理更新可以在一帧之中更新发生。由于图形方面的帧时间、对象的位置和其他属性在帧的开始被冻结，图形可能与更频繁更新的物理不同步。 自然你只有那么多 CPU 资源，但 Unity 可以让你选择有效降低物理时间来让帧处理跟上。Maximum Allowed Timestep(最大允许时间步长) 设置（在 Time 窗口中）给 Unity 用来处理物理的时间和FixedUpdate在一帧之间的调用做出了限制。如果一帧的更新用了超过 Maximum Allowed Timestep 来处理，物理引擎会“暂停时间”来让帧处理跟上。当帧更新完成，物理时间会恢复，且从上次暂停开始没有时间流动。结果是 rigidbodies(刚体) 相对现实时间不会像往常一样完美地移动，而是稍微变慢。但是，物理“时钟”会把它们当作正常移动。物理时间的变慢一般是难以察觉的而且对于游戏性能是可以接受的让步。 时间缩放 Time Scale 对于特别的效果，比如“时符「The World」”，有时候让时间暂缓来让动画和脚本响应发生在降低的速率会挺有用。更进一步，你可能有时候想要完全暂停时间，像游戏暂停。Unity 有一个 Time Scale(时间缩放) 属性可以控制相对于现实时间游戏进行得多块。如果比例被设置到1.0那么游戏时间和现实时间相同。2.0是两倍速度（动作会变快）而0.5速度会减缓到一半。0会让时间完全“停止”。注意时间缩放不会真正减慢程序执行而只是更改了通过方法 Time.deltaTime 和 Time.fixedDeltaTime 返回的时间步长。Update 方法会被调用得更加频繁，而每帧的 deltaTime 会减少。别的脚本方法不会受时间缩放影响，打个比方，当游戏暂停的时候你可以显示正常交互的 GUI 。 Time 窗口有可以让你设置全局时间缩放的属性，但是更常见的是在脚本中通过 Time.timeScale 属性设置。 //C# script example using UnityEngine; using System.Collections; public class ExampleScript : MonoBehaviour { void Pause() { Time.timeScale = 0; } void Resume() { Time.timeScale = 1; } } //JS script example function Pause() { Time.timeScale = 0; } function Resume() { Time.timeScale = 1; } 录制帧率 Capture Framerate 时间管理一个非常特殊的情况是当你想要录制游戏的时候。因为保存屏幕图像需要相当的时间，如果你尝试在普通的游戏进程中这么做，正常的游戏帧率会大大降低。这会导致视频不能体现正常的游戏表现。 幸运的是，Unity 提供了一个 Capture Framerate(录制帧率) 的属性可以让你解决这个问题。当这个属性的值设置成非零时，游戏的时间会变慢并且帧更新会定期精确进行。每帧的时间间隔等于 1 / Time.captureFramerate，所以如果值设成 5.0 那么更新每秒会发生五次。因为在帧率上的需求显著降低，你会有充足的时间去保存屏幕快照和进行其他行为： //C# 脚本范例 using UnityEngine; using System.Collections; public class ExampleScript : MonoBehaviour { // Capture frames as a screenshot sequence. Images are // stored as PNG files in a folder - these can be combined into // a movie using image utility software (eg, QuickTime Pro). // The folder to contain our screenshots. // If the folder exists we will append numbers to create an empty folder. string folder = \"ScreenshotFolder\"; int frameRate = 25; void Start () { // Set the playback framerate (real time will not relate to game time after this). Time.captureFramerate = frameRate; // Create the folder System.IO.Directory.CreateDirectory(folder); } void Update () { // Append filename to folder name (format is '0005 shot.png\"') string name = string.Format(\"{0}/{1:D04} shot.png\", folder, Time.frameCount ); // Capture the screenshot to the specified file. Application.CaptureScreenshot(name); } } //JS 脚本范例 // Capture frames as a screenshot sequence. Images are // stored as PNG files in a folder - these can be combined into // a movie using image utility software (eg, QuickTime Pro). // The folder to contain our screenshots. // If the folder exists we will append numbers to create an empty folder. var folder = \"ScreenshotFolder\"; var frameRate = 25; function Start () { // Set the playback framerate (real time will not relate to game time after this). Time.captureFramerate = frameRate; // Create the folder System.IO.Directory.CreateDirectory(folder); } function Update () { // Append filename to folder name (format is '0005 shot.png\"') var name = String.Format(\"{0}/{1:D04} shot.png\", folder, Time.frameCount ); // Capture the screenshot to the specified file. Application.CaptureScreenshot(name); } "},"Scripting/Scripting Overview/CreateDestroyObjects.html":{"url":"Scripting/Scripting Overview/CreateDestroyObjects.html","title":"Creating and Destroying GameObjects","keywords":"","body":"创建和销毁游戏对象 Creating and Destroying GameObjects 有一些游戏在场景中保持固定数量的对象，但对于角色、宝藏和其他对象来说，在游戏过程中创建和销毁它们是很常见的事。在 Unity，GameObject(游戏对象) 可以被 Instantiate(实例化) 方法创建，作为一个已存在的对象的副本： public GameObject enemy; void Start() { for (int i = 0; i 注意被复制对象必须要在场景中显示。使用从编辑器中的 Project(项目) 面板拖到公共变量的 prefab(预制件) 更加常用。同时，实例化一个 GameObject 会复制所有在原对象上的 Components(组件)。 还有一个 Destroy(销毁) 方法可以用来销毁对象，在帧更新完成后或者可选的短暂延时一会儿： void OnCollisionEnter(Collision otherObj) { if (otherObj.gameObject.tag == \"Missile\") { Destroy(gameObject,.5f); } } 注意 Destroy 方法可以摧毁个别组件而不影响 GameObject 自己。一个常见的错误： Destroy(this); 它只会摧毁调用这个函数的脚本组件，而不是摧毁它添加到的 GameObject。 "},"Scripting/Scripting Overview/Coroutines.html":{"url":"Scripting/Scripting Overview/Coroutines.html","title":"Coroutines","keywords":"","body":"协同函数 Conroutines 当你调用一个函数时，它会一直运行到它返回。这实际上意味着任何在函数中进行的动作必须在单次帧更新中发生；一次函数调用不能够包含渐变的动画或者一系列与时间有关的事件。举个核桃，我们要逐渐减少一个对象的 alpha 值（可见度）直到它完全不可见： void Fade() { for (float ft = 1f; ft >= 0; ft -= 0.1f) { Color c = renderer.material.color; c.a = ft; renderer.material.color = c; } } 如你所料，Fade(褪色) 方法不会发挥出你预期的效果。为了让褪色的过程可见，alpha 值必须在一段帧中逐渐减少来让中间的过程被渲染。但是，这段代码会在一帧之中执行完毕。中间值永远不会被看见，而对象会瞬间消失。 一个可能的解决方案是在 Update(更新) 方法中增加每一帧都褪色一点的代码来实现。可是，用协同函数(coroutine)来实现这类工作更加方便。 协同函数像是一种能够暂停执行并把控制权返回 Unity，但在随后的帧又可以在中断的地方继续的函数。在 C# 中，协同函数像这样声明： IEnumerator Fade() { for (float ft = 1f; ft >= 0; ft -= 0.1f) { Color c = renderer.material.color; c.a = ft; renderer.material.color = c; yield return null; } } 它本质上是一个返回值类型为 IEnumerator 和有 yield return 语句的方法。yield return null 行是程序暂停和在接下来的帧恢复的点。要使协同方法开始运行，你要用到 StartCoroutine 方法： void Update() { if (Input.GetKeyDown(\"f\")) { StartCoroutine(\"Fade\"); } } 你会注意到循环计数器在协同函数的生命周期内保持了它当前的值。实际上，任何变量或者参数在函数执行的间隙都会正确地保存。 默认协同函数会在暂停之后的下一帧恢复，但你也可以用 WaitForSeconds 实现延时： IEnumerator Fade() { for (float ft = 1f; ft >= 0; ft -= 0.1f) { Color c = renderer.material.color; c.a = ft; renderer.material.color = c; yield return new WaitForSeconds(.1f); } } 这个方法是把效果延伸一段时间的一种途径，但也是一种有用的优化手段。许多游戏中的任务需要逐渐进行，而最显然的方式是把代码放进 Update 方法中。但是，Update 方法每秒钟会被调用很多次。当一个任务不需要被如此频繁地调用时，你可以把它放在协同函数中来定期更新，但不是每一帧。一个例子是警告玩家敌人接近的警告。代码看起来长这样： function ProximityCheck() { for (int i = 0; i 如果有很多敌人，每一帧都调用这个方法可能会导致严重的过载。取而代之，你可以使用协同函数来每秒调用十次： IEnumerator DoCheck() { for(;;) { ProximityCheck(); yield return new WaitForSeconds(.1f); } } 这会大大减少检查的次数，而游戏过程不会产生任何可察觉的改变。 注意：你可以用 StopCoroutine 和 StopAllCoroutines 停止一个协同函数。当协同函数添加到的 GameObject(游戏对象) 被用 SetActive(false) 禁用的时候也会停止。调用Destroy(example)（当 example 是一个 MonoBehaviour 实例的时候）会马上触发 OnDisable 且协同函数会被调用，以有效地将它停止。最终，OnDestroy 会在帧结束的时候被调用。 当通过设置 enable 为 false 来禁用 MonoBehaivour 实例时，协同函数不会停止。 "},"Scripting/Scripting Overview/Namespaces.html":{"url":"Scripting/Scripting Overview/Namespaces.html","title":"Namespaces","keywords":"","body":"命名空间 Namespaces 当项目变得越来越大，脚本越来越多，类名冲突的可能性越来越大。当几个程序员在程序的不同方面分别同时工作，并最终要合并项目时显得尤其麻烦。举个例子，一个程序员可能会写控制主要角色的代码，当另一个程序员在为敌人写相同的代码的时候。两个程序员可能都会给他的类起名叫 Controller(控制器)，但当他们的项目合并时会导致崩溃。 这个问题可以通过命名约定或者改类名来在某种程度上解决（比如上面的类名，你可以改成 PlayerController 和 EnemyController），当崩溃发生时。但是，好几个类都撞车的时候，这就不大行了，你得挨个给它们重命名来让编译通过。 C# 语言提供了叫做命名空间的特性来有力地解决了这个问题。命名空间可以简单地理解成一打类类名前面自定义的前缀。在下面的例子，Controller1 和 Controller2 两个类是 Enermy 命名空间的成员。 namespace Enemy { public class Controller1 : MonoBehaviour { ... } public class Controller2 : MonoBehaviour { ... } } 在代码里，这两个类可以用 Enemy.Controller1 和 Enemy.Controller2 这种方式引用。这比重命名类好得多，因为声明命名空间可以把各种类分成不同的类别（比方说你不用挨个改名了）。更进一步，你可以在任何位置用多层的命名空间来包含类，甚至在不同的源文件。 你可以用在文件头用 using 来避免重复输入命名空间前缀： using Enermy; 这一行表明当出现叫 Controller1 和 Controller2 的类的时候，他们实际上意味着 Enemy.Controller1 和 Enemy.Controller2。如果这个脚本还要引用别的命名空间的同名类，你还是可以加命名空间前缀。如果两个有着同名类的命名空间被导入了，而你又调用了那个类，编译器就会报错。 "},"Scripting/Scripting Overview/Attributes.html":{"url":"Scripting/Scripting Overview/Attributes.html","title":"Attributes","keywords":"","body":"特性 Attributes 特性是可以放在类，属性和方法上面的标记来表现特殊的行为。举个例子，你可以在一个属性声明上添加 HideInInspector 特性来避免 Inspector(检查器) 显示这个属性，甚至它是公共的时候。C# 用方括号括住特性名，像这样： [HideInInspector] public float strength; Unity 提供了一系列特性，列在 API 参考文档里： 对于 UnityEngine 特性，查看 AddComponentMenu 和相关页面 对于 UnityEditor 特性，查看 CallbackOrderAttribute 和相关页面 也有在 .NET 库里定义的特性，有时候在 Unity 代码里会有用。查看 Microsoft’s documentation on Attributes 获取更多信息。 注意：不要用 .NET 库里定义的 ThreadStatic 特性；如果你加到 Unity 脚本里会导致崩溃。 "},"Scripting/Scripting Overview/ExecutionOrder.html":{"url":"Scripting/Scripting Overview/ExecutionOrder.html","title":"Order of Execution for Event Functions","keywords":"","body":"事件方法的执行顺序 Order of Execution for Event Functions 要运行一个 Unity 脚本，需要在预先决定好的顺序执行一系列的事件方法。这一页描述了这些事件方法以及他们是如何放进执行序列中的。 脚本生命周期概览 Script lifecycle overview 下面的表格总结了 Unity 如何在一个脚本的生命周期中安排和重复事件方法的。 要获取关于这么多事件方法的更多的信息，看看下面的章节： 脚本生命周期流程图 Ctrl+点击 以查看大图 注意： 部分浏览器不支持 SVG 图像文件。如果上面的图像显示不出来，那是时候加入 Mozilla Firefox 了。 第一次场景加载 First Scene load 这一些方法在 scene(场景) 开始时被调用（每个场景中的对象调用一次） Awake：这个方法总是在所有 Start 方法执行之前和所有 prefab(预制件) 实例化之后被调用。（如果在启动之前 GameObject 没有激活，Awake 不会被调用直到他被激活） OnEnable：（只在对象被激活的时候调用）：这个方法会在对象被启用之后马上被调用。这会在 MonoBehaviour 实例被创建的时候发生，比如当一个关卡被加载，或者一个添加了这个脚本组件的 GameObject 被实例化之后。 OnLevelWasLoaded：这个方法在一个关卡被完全加载的时候被调用。 注意对于所有加入到场景中的对象，所有脚本的 Awake 和 OnEnable 方法会在 Start、Update 等等任何其他方法被调用之前调用。一般情况下在游戏过程中对象被实例化不会被调用 Awake 和 OnEnable 方法。 编辑器 Editor Reset：Reset 在第一次添加到对象的时候和在运行 Reset 命令的时候被调用来初始化脚本的属性。 在第一次帧更新之前 Before the first frame update Start：Start 只在脚本实例被激活的时候在第一次帧更新之前被调用。 对于加到场景中的对象，Start 方法会在 Update 等方法调用之前在所有脚本中被调用。自然的，在游戏过程中对象被实例化不会调用这个方法。 在两帧之间 In between frames OnApplicationPause：这个方法在暂停被检测到的那一帧末尾被调用，实际上就是两次正常帧更新之间。在 OnApplicationPause 被调用之后，会添加一个额外帧来允许游戏显示暂停状态的图形。 更新顺序 Update Order 当你在保持跟踪游戏的逻辑、互动、动画、相机位置和等等其他的东西，有几个不同的事件可以使用。最常见的形式是在 Update 方法中完成大部分工作，但你也有别的方法可以用。 FixedUpdate：FixedUpdate 一般比 Update 调用得更加频繁。如果帧率很低，它可以在一帧中被调用几次，同时在帧率很高的时候可以一次都不被调用。所有物理计算和更新在 FixedUpdate 之后会马上发生。在 FixedUpdate 里计算移动距离的时候，你不需要把你的值乘上 Time.deltaTime。这是因为 FixedUpdate 被可靠的计时器定时调用，独立于帧率。 Update：Update每帧都被调用一次。这是帧更新的主要函数。 LateUpdate：LateUpdate 每帧调用一次，在 Update 被调用之后。任何在 Update 中的计算在 LateUpdate 开始之前都会完毕。常见的 LateUpdate 用法是一个第三人称跟踪相机。如果你在 Update 里计算角色的移动和旋转，你可以在 LateUpdate 里计算相机的移动和旋转。这会保证角色在相机跟踪他的位置时已经移动完毕了。 未完成 动画更新循环 Animation update loop QAQ 我真的看不懂这两节啊，可能是我没看过动画系统部分的原因？希望有人能帮我看一下……在这 这些方法和分析器标记会在 Unity 评估动画系统的时候被调用。 OnStateMachineEnter：在 State Machine Update(状态机更新) 阶段，这一个 这个回调函数只在动画图表包含了一个控制器组件（比如AnimatorController、AnimatorOverrideController 或 AnimatorControllerPlayable）的时候被调用。 注意： 把这个回调函数添加到 StateMachineBehaviour 组件会禁用多线程评估 state machine(状态机)。 OnStateMachineExit：在 这个回调函数只在动画图表包含了一个控制器组件（比如AnimatorController、AnimatorOverrideController 或 AnimatorControllerPlayable）的时候被调用。 注意： 把这个回调函数添加到 StateMachineBehaviour 组件会禁用多线程评估 state machine(状态机)。 Fire Animation Events： StateMachineBehaviour (OnStateEnter/OnStateUpdate/OnStateExit)： 未完成 Useful profile markers 渲染 Rendering OnPreCull：在相机挑选场景中显示的对象时被调用。选择决定了什么对象对于相机是可见的。OnPreCull 在挑选发生前一刻被调用。 OnBecameVisible/OnBecameInvisible：在某个对象对于任何相机变得可见/不可见时被调用。 OnWillRenderObject：对于任何相机可见的时候调用一次。 OnPreRender：在相机开始渲染场景的时候被调用。 OnRenderObject：在所有定期场景渲染完成之后被调用。你可以在这里使用 GL 类或者 Graphics.DrawMeshNow 来画自定义的几何图形。 OnPostRender：在一个相机完成渲染场景之后。 OnRenderImage：在场景渲染完毕以允许图像开始进行 post-processing(传递过程)，查看 Post-processing Effects。 OnGUI：每帧调用多次来对 GUI 事件进行响应。Layout(布局) 和 Repaint(重绘) 事件最先处理，接着是每一次输入的 Layout 和键盘/鼠标事件。 OnDrawGizmos：用来绘画场景窗口 中的 Gizmos 来实现可视化需求。 协同函数 Coroutines 普通的协同函数更新在 Update 方法返回后运行。协同函数是可以暂停执行（yield(中断)）直到给定的中断指令完成。不同的协同函数使用： yield 协同函数会在所有 Update 更新在下一帧被完成调用继续进行。 yield WaitForSeconds 在特定的延时后的协同函数，在这帧所有 Update 方法被调用之后被调用。 yield WaitForFixedUpdate 在所有脚本的 FixedUpdate 被调用之后的协同函数。 yield WWW 在一个 WWW 下载完成之后的协同函数。 yield StartCoroutine 把协同函数连接起来，并且等待 MyFunc 协同函数完毕。 当对象被摧毁 When the Object is destroyed OnDestroy：这个方法在这个对象存在的最后一帧中所有的帧更新完成之后被调用（对象可能会在这时作为对对象的响应被摧毁，也可能在场景关闭时被摧毁）。 当退出时 When quitting 这些方法会在所有场景中的活动对象上被调用。 OnApplicationQuit：这个方法会在程序退出前在所有游戏对象上被调用。在编辑器中这在用户停止播放模式时发生。 OnDisable：这个方法在行为(behaviour)被禁用或非激活时被调用。 "},"Scripting/Scripting Overview/UnderstandingAutomaticMemoryManagement.html":{"url":"Scripting/Scripting Overview/UnderstandingAutomaticMemoryManagement.html","title":"Understanding Automatic Memory Management","keywords":"","body":"理解自动内存管理 Understanding Automatic Memory Management 当一个对象、字符串或者数组被创建的时候，用来储存的内存从一个叫做堆的中心池分配。当物品不再需要的时候，他占用的内存可以重新分配来用作他用。在过去，这些任务完全由程序员来完成，通过正确地调用方法来精确地分配和释放内粗。如今，像 Unity 的 Mono 引擎这样的运行时系统可以为你自动地管理内存。自动内存管理比起精确地分配/释放需要更少的精力来码代码，并且可以大大减少潜在的内存泄漏（被分配的内存永远不会释放的情况）。 值和引用类型 Value and Reference Types 当一个方法被调用，它的参数的值会复制去一个保留的内存区域提供给那个特定的调用。传统数据类型只占用很少的字节并且可以非常快和简单地被复制。但是，对于对象、字符串和数组，他们常常占用大得多的内存，并且如果要复制他们会非常低效。幸运的是，这没必要；实际上储存这些大的东西的位置是从堆中分配的内存以及一个小“指针”值用来记住他的位置。从这时起，只有这个指针在传参过程中需要被复制。因为运行时系统可以通过指针定位这些东西，一份数据的复制可以尽可能地频繁使用。 在传参过程中可以直接储存和使用的值叫做数据类型。这包括整形，浮点值，布尔和 Unity 的结构体类型（比如 Color 和 Vector3）。被分配到堆里并通过指针访问的类型叫引用类型，因为这些储存在变量里的值只是“引用”到了真实的值。引用类型的例子有对象、字符串和数组。 分配和垃圾回收 Allocation and Garabge Collection 内存管理器保持对堆中的空间进行跟踪以确保他清楚哪些空间可以用。当有一块新的内存需求的时候（比如有个对象要被实例化了），管理器选择一块没有使用的空间，用来分配内存并把这块内存移出未使用区域。以后的需求也是以同样的方式处理，直到已经没有足够大的空间来分配内存。在这时所有在堆中分配的内存不可能还全部在使用中。一个在堆中被引用的东西只能在还有引用值存在的时候被引用。如果对一个内存块所有的引用都丢失了（比如引用值被重新分配或者是超出范围的局部变量）那么他占用的这一块内存可以被安全地重新分配。 为了弄清楚那一块堆块不再需要被使用，内存管理器会遍历所有激活的引用值并标记他们引用到的块为“活动”。在搜索结束时，任何活动块之间的空间会被内存管理器认为是空闲的，并可以用作随后的内存分配。显而易见的，定位和释放无用内存的过程被称作垃圾回收。 Uinty 使用 Boehm–Demers–Weiser garbage collector，一个停止世界（？）的垃圾回收器。无论何时 Unity 需要进行垃圾回收，他会停止运行你的代码并只在结束他的工作之后恢复。这个中断会导致你游戏的执行在任何地方都产生从少于1毫秒到几百毫秒的延迟，这取决于垃圾回收器要处理多少内存和游戏运行的平台。对于与现实时间同步的程序像是游戏，这会造成大问题，因为你在垃圾回收器中断游戏执行的时候不能保持稳定的帧率来使动画平滑。这些中断被称为 GC(垃圾回收) spikes(钉子)（卡顿），因为他们在 Profiler(分析器) 帧时间图形中显示得像钉子一样。在下一部分你会学到如何写代码来避免游戏过程中不必要的通过垃圾回收的内存分配，以使垃圾回收器有更少的工作要做。 优化 Optimization 垃圾回收对于程序员来说是自动和不可见的，但是回收过程实际上在场景背后占用了显著的 CPU 时间。当使用恰当，自动垃圾回收管理一般可以在所有表现中等价或者超过人工分配。但是，对于程序员很重要的一点是避免会导致不必要地频繁触发回收器并导致运行终端的错误。 这里有一些不出名的算法，他们可以导致 GC 的噩梦，甚至第一眼看上他们是无辜的（粉切黑QvQ）。重复字符串连接是一个经典的例子： //C# script example using UnityEngine; using System.Collections; public class ExampleScript : MonoBehaviour { void ConcatExample(int[] intArray) { string line = intArray[0].ToString(); for (i = 1; i 这里的关键点是新的片段不会加到已有的后面，一个接一个。真正发生的是每一次循环，之前的行内容被丢弃了——一个完整的字符串被分配来包含之前的内容再在末尾加上新的片段。随着 i 的增长字符串越变越长，堆空间的使用量约会越来越多，而每次方法调用都会轻易的花掉数百字节的空间。如果你需要把许多字符串连接到一起，一个更好的选择是使用 Mono 库的 System.Text.StringBuilder 类。 然而，甚至重复的链接不会引起太多问题，如果他不被频繁调用，而“频繁调用”在 Unity 中经常意味着帧更新。像这样： //C# script example using UnityEngine; using System.Collections; public class ExampleScript : MonoBehaviour { public GUIText scoreBoard; public int score; void Update() { string scoreText = \"Score: \" + score.ToString(); scoreBoard.text = scoreText; } } 会在每次 Update 方法被调用的时候分配新字符串空间并产生细水长流的垃圾。大多数空间都可以通过只在分数变更的时候才更新的方式来节约： //C# script example using UnityEngine; using System.Collections; public class ExampleScript : MonoBehaviour { public GUIText scoreBoard; public string scoreText; public int score; public int oldScore; void Update() { if (score != oldScore) { scoreText = \"Score: \" + score.ToString(); scoreBoard.text = scoreText; oldScore = score; } } } 当一个方法返回数组的时候会触发另一个潜在的问题： //C# script example using UnityEngine; using System.Collections; public class ExampleScript : MonoBehaviour { float[] RandomList(int numElements) { var result = new float[numElements]; for (int i = 0; i 这类型的函数在创建一个被数值填充的新数组的时候十分优雅和方便。但是，如果它被调用地太频繁，那么新释放的内存每一次都会被分配。因为数组可以变得非常大，新的堆空间可以被非常快地使用掉，而这反映在频繁的垃圾回收上。一个避免这个问题的方式是利用数组是引用类型这个事实。一个通过参数传递到方法的数组可以在那个方法中被修改，并且结果会在方法返回后被保留。一个向上面那样的方法常常可以被像这样的东西取代： //C# script example using UnityEngine; using System.Collections; public class ExampleScript : MonoBehaviour { void RandomList(float[] arrayToFill) { for (int i = 0; i 这简单地用新数值重新填充了已有数组的数值。尽管这需要在调用函数的代码中初始化分配数组（看起来一点也不优雅），函数在调用时不会产生任何垃圾。 关闭垃圾分类 Disabling garbage collection 如果你在使用 Mono 或者 IL2CPP scripting backend(脚本后端)，你可以通过在运行时关闭垃圾回收来避免 CPU 卡顿。当你关闭垃圾回收，内存使用永远不会降低因为垃圾回收器不再回收不再有任何引用的对象。事实上，内存使用在你关闭垃圾回收器之后只能一直攀升。为了避免过长时间占用太多内存，要注意管理内存。理想情况下，在垃圾管理器关闭前分配好所有的内存并避免更多的分配当他关闭之后。 获取更多关于如何在运行时启用和关闭垃圾回收的细节，查看 GarbageCollector 编程 API 页面。 你也可以尝试 Incremental garbage collection option。 请求一次回收 Requesting a Collection 向上面提到的那样，最好尽可能地避免内存分配。然而，考虑到它们不可能被完全消除，你可以使用两种主要策略来最小化它们对游戏的干扰。 拥有迅速和频繁垃圾回收的小堆 这种策略最适用于拥有长时间的过程而帧率是重中之重的游戏。这种游戏常常频繁地申请小块的内存但这些小块只会短暂地被使用。使用这种策略的经典堆大小在 iOS 上大约是 200KB，并且垃圾回收在 iPhone 3G 上大约会花费 5ms。如果堆大小增至 1M，垃圾回收会花费 7ms。因此定期在帧之间请求垃圾回收会有优势。这常常会使垃圾回收发生得比严格需求更频繁，但是他会迅速处理完毕并对游戏产生最小的影响： if (Time.frameCount % 30 == 0) { System.GC.Collect(); } 然而，你应该谨慎地使用这个技术并检查 profiler(分析器) 的状态来确保真的减少了你的游戏的回收时间。 拥有慢但是不频繁的垃圾回收的大堆 这个策略最适用于申请内存（因此回收也是）相当不频繁并可以在游戏暂停时被处理。堆在不会被系统因为占用内存过高而被杀死的前提下越大越好。然而，Mono 运行时会避免拓展堆空间，尽管完全可以。你可以通过在启动时预分配一些占位空间来手动拓展堆空间（比如你可以实例化一个“没用”的对象来仅仅利用它对内存管理器的影响）： //C# script example using UnityEngine; using System.Collections; public class ExampleScript : MonoBehaviour { void Start() { var tmp = new System.Object[1024]; // make allocations in smaller blocks to avoid them to be treated in a special way, which is designed for large blocks for (int i = 0; i 一个足够大的堆在两次暂停之间不应该被占用至必须回收。当这样的暂停发生时，你可以显式地请求一次回收： System.GC.Collect(); 一样的，你应该谨慎地使用这个策略并注意 profiler(分析器) 状态而不是假设它发挥了预期的作用。 可重用对象池 Reusable Object Pools 在很多情况下你可以简单地通过减少对象的创建和销毁来避免产生垃圾。有很多特定种类的对象，像子弹，会在游戏中重复遇见，尽管只有很小一部分会显示出来。像这样的情况，比起创建旧的并用新的替换掉，重用他们总是可能的。 逐步垃圾回收 Incremental Garabge Collection 注意： 这是一个预览功能并且容易被更改。任何使用了这个功能的项目可能需要在未来的更新中升级。不要在完整的产品中依赖这个功能直到这个功能正式发布。 Incremental Garbage Collection(逐步垃圾回收) 把要进行的工作分发来使垃圾回收在多个帧中进行。 使用逐步垃圾回收，Unity 仍然使用 Boehm–Demers–Weiser 垃圾回收器，但在逐步模式中运行它。比起在每次运行它时做一次完全的垃圾回收，Unity 把垃圾回收负载分散在多个帧中。所以比起通过一次你的程序的长中断来让垃圾回收器完成他的工作，你会得到多次但大大缩短的中断。尽管这完全不能让垃圾回收快一丁点，这还是可以显著的减少垃圾回收的卡顿破坏你的游戏的顺滑，通过把负载分散到几个帧的方式。 接下来来自 Unity 分析器的截图，有和没有足部垃圾回收，表现了逐步垃圾回收如何减少帧率卡顿。在这些分析器图形中，淡蓝色部分表示了脚本操作的时间，黄色部分表示了在 Vsync（等待下一帧开始）之前的剩余时间，而深绿色（明明是深黄褐色）部分表示了垃圾回收的时间。 Nonincremental garbage collection profile 不包含逐步垃圾回收（上面这个），你可以看见卡顿中断了其他地方顺滑的 60fps 帧率。这次卡顿使垃圾回收发生的那一帧推迟了远超过 16 毫秒，而这是保持 60fps 的限制。（实际上，这个例子因为垃圾回收影响了超过一帧） Incremental garbage collection profile 使用逐步垃圾回收（上面），相同的项目保持了他的恒定的 60fps 帧率，因为垃圾回收操作分割在了几个帧里，而每一帧只用了短暂的时间（深绿色区域刚刚好在黄色的 Vsync 图像上）。 Incremental garbage collection using left over time in frame 这个截图表示了相同的也有逐步垃圾回收的项目，但这一次每帧的脚本运行时间更短。同样，垃圾回收操作被分散到几个帧里。不同的是这一次，垃圾回收每帧消耗了更多的时间，并且需要更少的总帧数来完成。这是因为我们基于剩余的可用帧时间调整分配给垃圾回收的时间，如果启用了 Vsync 或者 Application.targetFrameRate。通过这种方式，我们可以及时地运行垃圾回收，而不是等待，从而“免费”进行垃圾回收。 启用逐步垃圾回收 Enabling incremental garbage collection 逐步垃圾回收现在可用于以下平台： Mac standalone player Windows standalone player Linux standalone player iOS Android Windows UWP player PS4 Xbox One Nintendo Switch Unity Editor 注意逐步垃圾回收现在还不能用于 WebGL。逐步垃圾回收需要 .NET 4.x 运行时。 在支持的平台，Unity 在 Player settings(用户设置) 窗口里的“Other settings(其他设置)”区域提供了启用逐步垃圾回收的选项。只要选中 Use incremental GC 复选框。 Player Settings to enable incremental garbage collection 另外，如果你在你项目的 Quality 设置 VSync Count 的值为 Don't Sync 以外的值或者使用了 Application.VSync 属性或者你设置了 Application.targetFrameRate 属性，Unity 会自动使用任何给定帧的剩余空闲时间来逐步垃圾回收。 你可以使用 Scripting.GarbageCollector 类来探索更精确的足部垃圾回收控制。举个例子，如果你不想用 VSync 或者目标帧率，你可以自己计算在帧结束之前的可用时间并提供给垃圾回收使用。 逐步垃圾回收可能导致的问题 Possible problems with incremental collection 在大多数情况，逐步垃圾回收可以减缓垃圾回收卡顿的问题。但是，在某些情况下，逐步垃圾回收可能在实际情况下没有效果。 当逐步垃圾回收中断工作时，它中断了用来扫描所有对象来决定哪些对象是没有用的匹配阶段。当大多数对象的引用在工作间隙间没有变化时。当一个对象引用改变了，这一些对象必须在下一次被重新扫描。因此，太多的改变会压垮逐步垃圾回收并导致扫描工作永远不能完成，因为它总是有更多的工作要做——在这种情况，垃圾回收会退化到一次完整的，非逐步的回收。 同样的，当使用逐步垃圾回收，Unity 需要生成额外的代码（）来让垃圾回收器知道任何时候一个引用有没有改变（好知道要不要重新扫描它）。这些增加的代码的开销在更改引用时会对性能产生不可忽略的影响。 仍然，大多数经典的 Unity 项目（如果真的有“经典” Unity 项目的话）可以从逐步垃圾回收中受益，特别是受困于垃圾回收卡顿的那些。 注意常常使用 Profiler(分析器) 来确认你的游戏或者程序像你期待一样表现。 更进一步 Further Information 内存管理是一个微妙而复杂的课题，许多学术研究都致力于此。如果你对于学习更多有兴趣，memorymanagement.org 有着优秀的资源，列举了很多出版物和在线文章。关于对象池的更远一步的信息可以在 维基页面 或者 Sourcemaking.com 上找到。 "}}